// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	v1a "k8s.io/api/core/v1"
	v1d "k8s.io/api/policy/v1"
	"k8s.io/api/policy/v1beta1"
	v1c "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	v1b "k8s.io/client-go/applyconfigurations/core/v1"
	v1 "k8s.io/client-go/kubernetes/typed/core/v1"
	"k8s.io/client-go/rest"
)

type PodInterface struct {
	ApplyStub        func(context.Context, *v1b.PodApplyConfiguration, v1c.ApplyOptions) (*v1a.Pod, error)
	applyMutex       sync.RWMutex
	applyArgsForCall []struct {
		arg1 context.Context
		arg2 *v1b.PodApplyConfiguration
		arg3 v1c.ApplyOptions
	}
	applyReturns struct {
		result1 *v1a.Pod
		result2 error
	}
	applyReturnsOnCall map[int]struct {
		result1 *v1a.Pod
		result2 error
	}
	ApplyStatusStub        func(context.Context, *v1b.PodApplyConfiguration, v1c.ApplyOptions) (*v1a.Pod, error)
	applyStatusMutex       sync.RWMutex
	applyStatusArgsForCall []struct {
		arg1 context.Context
		arg2 *v1b.PodApplyConfiguration
		arg3 v1c.ApplyOptions
	}
	applyStatusReturns struct {
		result1 *v1a.Pod
		result2 error
	}
	applyStatusReturnsOnCall map[int]struct {
		result1 *v1a.Pod
		result2 error
	}
	BindStub        func(context.Context, *v1a.Binding, v1c.CreateOptions) error
	bindMutex       sync.RWMutex
	bindArgsForCall []struct {
		arg1 context.Context
		arg2 *v1a.Binding
		arg3 v1c.CreateOptions
	}
	bindReturns struct {
		result1 error
	}
	bindReturnsOnCall map[int]struct {
		result1 error
	}
	CreateStub        func(context.Context, *v1a.Pod, v1c.CreateOptions) (*v1a.Pod, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 context.Context
		arg2 *v1a.Pod
		arg3 v1c.CreateOptions
	}
	createReturns struct {
		result1 *v1a.Pod
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *v1a.Pod
		result2 error
	}
	DeleteStub        func(context.Context, string, v1c.DeleteOptions) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 v1c.DeleteOptions
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteCollectionStub        func(context.Context, v1c.DeleteOptions, v1c.ListOptions) error
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		arg1 context.Context
		arg2 v1c.DeleteOptions
		arg3 v1c.ListOptions
	}
	deleteCollectionReturns struct {
		result1 error
	}
	deleteCollectionReturnsOnCall map[int]struct {
		result1 error
	}
	EvictStub        func(context.Context, *v1beta1.Eviction) error
	evictMutex       sync.RWMutex
	evictArgsForCall []struct {
		arg1 context.Context
		arg2 *v1beta1.Eviction
	}
	evictReturns struct {
		result1 error
	}
	evictReturnsOnCall map[int]struct {
		result1 error
	}
	EvictV1Stub        func(context.Context, *v1d.Eviction) error
	evictV1Mutex       sync.RWMutex
	evictV1ArgsForCall []struct {
		arg1 context.Context
		arg2 *v1d.Eviction
	}
	evictV1Returns struct {
		result1 error
	}
	evictV1ReturnsOnCall map[int]struct {
		result1 error
	}
	EvictV1beta1Stub        func(context.Context, *v1beta1.Eviction) error
	evictV1beta1Mutex       sync.RWMutex
	evictV1beta1ArgsForCall []struct {
		arg1 context.Context
		arg2 *v1beta1.Eviction
	}
	evictV1beta1Returns struct {
		result1 error
	}
	evictV1beta1ReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(context.Context, string, v1c.GetOptions) (*v1a.Pod, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 v1c.GetOptions
	}
	getReturns struct {
		result1 *v1a.Pod
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *v1a.Pod
		result2 error
	}
	GetLogsStub        func(string, *v1a.PodLogOptions) *rest.Request
	getLogsMutex       sync.RWMutex
	getLogsArgsForCall []struct {
		arg1 string
		arg2 *v1a.PodLogOptions
	}
	getLogsReturns struct {
		result1 *rest.Request
	}
	getLogsReturnsOnCall map[int]struct {
		result1 *rest.Request
	}
	ListStub        func(context.Context, v1c.ListOptions) (*v1a.PodList, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 context.Context
		arg2 v1c.ListOptions
	}
	listReturns struct {
		result1 *v1a.PodList
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 *v1a.PodList
		result2 error
	}
	PatchStub        func(context.Context, string, types.PatchType, []byte, v1c.PatchOptions, ...string) (*v1a.Pod, error)
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 types.PatchType
		arg4 []byte
		arg5 v1c.PatchOptions
		arg6 []string
	}
	patchReturns struct {
		result1 *v1a.Pod
		result2 error
	}
	patchReturnsOnCall map[int]struct {
		result1 *v1a.Pod
		result2 error
	}
	ProxyGetStub        func(string, string, string, string, map[string]string) rest.ResponseWrapper
	proxyGetMutex       sync.RWMutex
	proxyGetArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 map[string]string
	}
	proxyGetReturns struct {
		result1 rest.ResponseWrapper
	}
	proxyGetReturnsOnCall map[int]struct {
		result1 rest.ResponseWrapper
	}
	UpdateStub        func(context.Context, *v1a.Pod, v1c.UpdateOptions) (*v1a.Pod, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 *v1a.Pod
		arg3 v1c.UpdateOptions
	}
	updateReturns struct {
		result1 *v1a.Pod
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *v1a.Pod
		result2 error
	}
	UpdateEphemeralContainersStub        func(context.Context, string, *v1a.Pod, v1c.UpdateOptions) (*v1a.Pod, error)
	updateEphemeralContainersMutex       sync.RWMutex
	updateEphemeralContainersArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *v1a.Pod
		arg4 v1c.UpdateOptions
	}
	updateEphemeralContainersReturns struct {
		result1 *v1a.Pod
		result2 error
	}
	updateEphemeralContainersReturnsOnCall map[int]struct {
		result1 *v1a.Pod
		result2 error
	}
	UpdateStatusStub        func(context.Context, *v1a.Pod, v1c.UpdateOptions) (*v1a.Pod, error)
	updateStatusMutex       sync.RWMutex
	updateStatusArgsForCall []struct {
		arg1 context.Context
		arg2 *v1a.Pod
		arg3 v1c.UpdateOptions
	}
	updateStatusReturns struct {
		result1 *v1a.Pod
		result2 error
	}
	updateStatusReturnsOnCall map[int]struct {
		result1 *v1a.Pod
		result2 error
	}
	WatchStub        func(context.Context, v1c.ListOptions) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		arg1 context.Context
		arg2 v1c.ListOptions
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	watchReturnsOnCall map[int]struct {
		result1 watch.Interface
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *PodInterface) Apply(arg1 context.Context, arg2 *v1b.PodApplyConfiguration, arg3 v1c.ApplyOptions) (*v1a.Pod, error) {
	fake.applyMutex.Lock()
	ret, specificReturn := fake.applyReturnsOnCall[len(fake.applyArgsForCall)]
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct {
		arg1 context.Context
		arg2 *v1b.PodApplyConfiguration
		arg3 v1c.ApplyOptions
	}{arg1, arg2, arg3})
	stub := fake.ApplyStub
	fakeReturns := fake.applyReturns
	fake.recordInvocation("Apply", []interface{}{arg1, arg2, arg3})
	fake.applyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *PodInterface) ApplyCalls(stub func(context.Context, *v1b.PodApplyConfiguration, v1c.ApplyOptions) (*v1a.Pod, error)) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = stub
}

func (fake *PodInterface) ApplyArgsForCall(i int) (context.Context, *v1b.PodApplyConfiguration, v1c.ApplyOptions) {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	argsForCall := fake.applyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) ApplyReturns(result1 *v1a.Pod, result2 error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) ApplyReturnsOnCall(i int, result1 *v1a.Pod, result2 error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = nil
	if fake.applyReturnsOnCall == nil {
		fake.applyReturnsOnCall = make(map[int]struct {
			result1 *v1a.Pod
			result2 error
		})
	}
	fake.applyReturnsOnCall[i] = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) ApplyStatus(arg1 context.Context, arg2 *v1b.PodApplyConfiguration, arg3 v1c.ApplyOptions) (*v1a.Pod, error) {
	fake.applyStatusMutex.Lock()
	ret, specificReturn := fake.applyStatusReturnsOnCall[len(fake.applyStatusArgsForCall)]
	fake.applyStatusArgsForCall = append(fake.applyStatusArgsForCall, struct {
		arg1 context.Context
		arg2 *v1b.PodApplyConfiguration
		arg3 v1c.ApplyOptions
	}{arg1, arg2, arg3})
	stub := fake.ApplyStatusStub
	fakeReturns := fake.applyStatusReturns
	fake.recordInvocation("ApplyStatus", []interface{}{arg1, arg2, arg3})
	fake.applyStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) ApplyStatusCallCount() int {
	fake.applyStatusMutex.RLock()
	defer fake.applyStatusMutex.RUnlock()
	return len(fake.applyStatusArgsForCall)
}

func (fake *PodInterface) ApplyStatusCalls(stub func(context.Context, *v1b.PodApplyConfiguration, v1c.ApplyOptions) (*v1a.Pod, error)) {
	fake.applyStatusMutex.Lock()
	defer fake.applyStatusMutex.Unlock()
	fake.ApplyStatusStub = stub
}

func (fake *PodInterface) ApplyStatusArgsForCall(i int) (context.Context, *v1b.PodApplyConfiguration, v1c.ApplyOptions) {
	fake.applyStatusMutex.RLock()
	defer fake.applyStatusMutex.RUnlock()
	argsForCall := fake.applyStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) ApplyStatusReturns(result1 *v1a.Pod, result2 error) {
	fake.applyStatusMutex.Lock()
	defer fake.applyStatusMutex.Unlock()
	fake.ApplyStatusStub = nil
	fake.applyStatusReturns = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) ApplyStatusReturnsOnCall(i int, result1 *v1a.Pod, result2 error) {
	fake.applyStatusMutex.Lock()
	defer fake.applyStatusMutex.Unlock()
	fake.ApplyStatusStub = nil
	if fake.applyStatusReturnsOnCall == nil {
		fake.applyStatusReturnsOnCall = make(map[int]struct {
			result1 *v1a.Pod
			result2 error
		})
	}
	fake.applyStatusReturnsOnCall[i] = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) Bind(arg1 context.Context, arg2 *v1a.Binding, arg3 v1c.CreateOptions) error {
	fake.bindMutex.Lock()
	ret, specificReturn := fake.bindReturnsOnCall[len(fake.bindArgsForCall)]
	fake.bindArgsForCall = append(fake.bindArgsForCall, struct {
		arg1 context.Context
		arg2 *v1a.Binding
		arg3 v1c.CreateOptions
	}{arg1, arg2, arg3})
	stub := fake.BindStub
	fakeReturns := fake.bindReturns
	fake.recordInvocation("Bind", []interface{}{arg1, arg2, arg3})
	fake.bindMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PodInterface) BindCallCount() int {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return len(fake.bindArgsForCall)
}

func (fake *PodInterface) BindCalls(stub func(context.Context, *v1a.Binding, v1c.CreateOptions) error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = stub
}

func (fake *PodInterface) BindArgsForCall(i int) (context.Context, *v1a.Binding, v1c.CreateOptions) {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	argsForCall := fake.bindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) BindReturns(result1 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	fake.bindReturns = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) BindReturnsOnCall(i int, result1 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	if fake.bindReturnsOnCall == nil {
		fake.bindReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bindReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) Create(arg1 context.Context, arg2 *v1a.Pod, arg3 v1c.CreateOptions) (*v1a.Pod, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 context.Context
		arg2 *v1a.Pod
		arg3 v1c.CreateOptions
	}{arg1, arg2, arg3})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{arg1, arg2, arg3})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *PodInterface) CreateCalls(stub func(context.Context, *v1a.Pod, v1c.CreateOptions) (*v1a.Pod, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *PodInterface) CreateArgsForCall(i int) (context.Context, *v1a.Pod, v1c.CreateOptions) {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) CreateReturns(result1 *v1a.Pod, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) CreateReturnsOnCall(i int, result1 *v1a.Pod, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *v1a.Pod
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) Delete(arg1 context.Context, arg2 string, arg3 v1c.DeleteOptions) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 v1c.DeleteOptions
	}{arg1, arg2, arg3})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PodInterface) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *PodInterface) DeleteCalls(stub func(context.Context, string, v1c.DeleteOptions) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *PodInterface) DeleteArgsForCall(i int) (context.Context, string, v1c.DeleteOptions) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) DeleteCollection(arg1 context.Context, arg2 v1c.DeleteOptions, arg3 v1c.ListOptions) error {
	fake.deleteCollectionMutex.Lock()
	ret, specificReturn := fake.deleteCollectionReturnsOnCall[len(fake.deleteCollectionArgsForCall)]
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		arg1 context.Context
		arg2 v1c.DeleteOptions
		arg3 v1c.ListOptions
	}{arg1, arg2, arg3})
	stub := fake.DeleteCollectionStub
	fakeReturns := fake.deleteCollectionReturns
	fake.recordInvocation("DeleteCollection", []interface{}{arg1, arg2, arg3})
	fake.deleteCollectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PodInterface) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *PodInterface) DeleteCollectionCalls(stub func(context.Context, v1c.DeleteOptions, v1c.ListOptions) error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = stub
}

func (fake *PodInterface) DeleteCollectionArgsForCall(i int) (context.Context, v1c.DeleteOptions, v1c.ListOptions) {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	argsForCall := fake.deleteCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) DeleteCollectionReturns(result1 error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) DeleteCollectionReturnsOnCall(i int, result1 error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	if fake.deleteCollectionReturnsOnCall == nil {
		fake.deleteCollectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCollectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) Evict(arg1 context.Context, arg2 *v1beta1.Eviction) error {
	fake.evictMutex.Lock()
	ret, specificReturn := fake.evictReturnsOnCall[len(fake.evictArgsForCall)]
	fake.evictArgsForCall = append(fake.evictArgsForCall, struct {
		arg1 context.Context
		arg2 *v1beta1.Eviction
	}{arg1, arg2})
	stub := fake.EvictStub
	fakeReturns := fake.evictReturns
	fake.recordInvocation("Evict", []interface{}{arg1, arg2})
	fake.evictMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PodInterface) EvictCallCount() int {
	fake.evictMutex.RLock()
	defer fake.evictMutex.RUnlock()
	return len(fake.evictArgsForCall)
}

func (fake *PodInterface) EvictCalls(stub func(context.Context, *v1beta1.Eviction) error) {
	fake.evictMutex.Lock()
	defer fake.evictMutex.Unlock()
	fake.EvictStub = stub
}

func (fake *PodInterface) EvictArgsForCall(i int) (context.Context, *v1beta1.Eviction) {
	fake.evictMutex.RLock()
	defer fake.evictMutex.RUnlock()
	argsForCall := fake.evictArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *PodInterface) EvictReturns(result1 error) {
	fake.evictMutex.Lock()
	defer fake.evictMutex.Unlock()
	fake.EvictStub = nil
	fake.evictReturns = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) EvictReturnsOnCall(i int, result1 error) {
	fake.evictMutex.Lock()
	defer fake.evictMutex.Unlock()
	fake.EvictStub = nil
	if fake.evictReturnsOnCall == nil {
		fake.evictReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.evictReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) EvictV1(arg1 context.Context, arg2 *v1d.Eviction) error {
	fake.evictV1Mutex.Lock()
	ret, specificReturn := fake.evictV1ReturnsOnCall[len(fake.evictV1ArgsForCall)]
	fake.evictV1ArgsForCall = append(fake.evictV1ArgsForCall, struct {
		arg1 context.Context
		arg2 *v1d.Eviction
	}{arg1, arg2})
	stub := fake.EvictV1Stub
	fakeReturns := fake.evictV1Returns
	fake.recordInvocation("EvictV1", []interface{}{arg1, arg2})
	fake.evictV1Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PodInterface) EvictV1CallCount() int {
	fake.evictV1Mutex.RLock()
	defer fake.evictV1Mutex.RUnlock()
	return len(fake.evictV1ArgsForCall)
}

func (fake *PodInterface) EvictV1Calls(stub func(context.Context, *v1d.Eviction) error) {
	fake.evictV1Mutex.Lock()
	defer fake.evictV1Mutex.Unlock()
	fake.EvictV1Stub = stub
}

func (fake *PodInterface) EvictV1ArgsForCall(i int) (context.Context, *v1d.Eviction) {
	fake.evictV1Mutex.RLock()
	defer fake.evictV1Mutex.RUnlock()
	argsForCall := fake.evictV1ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *PodInterface) EvictV1Returns(result1 error) {
	fake.evictV1Mutex.Lock()
	defer fake.evictV1Mutex.Unlock()
	fake.EvictV1Stub = nil
	fake.evictV1Returns = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) EvictV1ReturnsOnCall(i int, result1 error) {
	fake.evictV1Mutex.Lock()
	defer fake.evictV1Mutex.Unlock()
	fake.EvictV1Stub = nil
	if fake.evictV1ReturnsOnCall == nil {
		fake.evictV1ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.evictV1ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) EvictV1beta1(arg1 context.Context, arg2 *v1beta1.Eviction) error {
	fake.evictV1beta1Mutex.Lock()
	ret, specificReturn := fake.evictV1beta1ReturnsOnCall[len(fake.evictV1beta1ArgsForCall)]
	fake.evictV1beta1ArgsForCall = append(fake.evictV1beta1ArgsForCall, struct {
		arg1 context.Context
		arg2 *v1beta1.Eviction
	}{arg1, arg2})
	stub := fake.EvictV1beta1Stub
	fakeReturns := fake.evictV1beta1Returns
	fake.recordInvocation("EvictV1beta1", []interface{}{arg1, arg2})
	fake.evictV1beta1Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PodInterface) EvictV1beta1CallCount() int {
	fake.evictV1beta1Mutex.RLock()
	defer fake.evictV1beta1Mutex.RUnlock()
	return len(fake.evictV1beta1ArgsForCall)
}

func (fake *PodInterface) EvictV1beta1Calls(stub func(context.Context, *v1beta1.Eviction) error) {
	fake.evictV1beta1Mutex.Lock()
	defer fake.evictV1beta1Mutex.Unlock()
	fake.EvictV1beta1Stub = stub
}

func (fake *PodInterface) EvictV1beta1ArgsForCall(i int) (context.Context, *v1beta1.Eviction) {
	fake.evictV1beta1Mutex.RLock()
	defer fake.evictV1beta1Mutex.RUnlock()
	argsForCall := fake.evictV1beta1ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *PodInterface) EvictV1beta1Returns(result1 error) {
	fake.evictV1beta1Mutex.Lock()
	defer fake.evictV1beta1Mutex.Unlock()
	fake.EvictV1beta1Stub = nil
	fake.evictV1beta1Returns = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) EvictV1beta1ReturnsOnCall(i int, result1 error) {
	fake.evictV1beta1Mutex.Lock()
	defer fake.evictV1beta1Mutex.Unlock()
	fake.EvictV1beta1Stub = nil
	if fake.evictV1beta1ReturnsOnCall == nil {
		fake.evictV1beta1ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.evictV1beta1ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *PodInterface) Get(arg1 context.Context, arg2 string, arg3 v1c.GetOptions) (*v1a.Pod, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 v1c.GetOptions
	}{arg1, arg2, arg3})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *PodInterface) GetCalls(stub func(context.Context, string, v1c.GetOptions) (*v1a.Pod, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *PodInterface) GetArgsForCall(i int) (context.Context, string, v1c.GetOptions) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) GetReturns(result1 *v1a.Pod, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) GetReturnsOnCall(i int, result1 *v1a.Pod, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *v1a.Pod
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) GetLogs(arg1 string, arg2 *v1a.PodLogOptions) *rest.Request {
	fake.getLogsMutex.Lock()
	ret, specificReturn := fake.getLogsReturnsOnCall[len(fake.getLogsArgsForCall)]
	fake.getLogsArgsForCall = append(fake.getLogsArgsForCall, struct {
		arg1 string
		arg2 *v1a.PodLogOptions
	}{arg1, arg2})
	stub := fake.GetLogsStub
	fakeReturns := fake.getLogsReturns
	fake.recordInvocation("GetLogs", []interface{}{arg1, arg2})
	fake.getLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PodInterface) GetLogsCallCount() int {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	return len(fake.getLogsArgsForCall)
}

func (fake *PodInterface) GetLogsCalls(stub func(string, *v1a.PodLogOptions) *rest.Request) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = stub
}

func (fake *PodInterface) GetLogsArgsForCall(i int) (string, *v1a.PodLogOptions) {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	argsForCall := fake.getLogsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *PodInterface) GetLogsReturns(result1 *rest.Request) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = nil
	fake.getLogsReturns = struct {
		result1 *rest.Request
	}{result1}
}

func (fake *PodInterface) GetLogsReturnsOnCall(i int, result1 *rest.Request) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = nil
	if fake.getLogsReturnsOnCall == nil {
		fake.getLogsReturnsOnCall = make(map[int]struct {
			result1 *rest.Request
		})
	}
	fake.getLogsReturnsOnCall[i] = struct {
		result1 *rest.Request
	}{result1}
}

func (fake *PodInterface) List(arg1 context.Context, arg2 v1c.ListOptions) (*v1a.PodList, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 context.Context
		arg2 v1c.ListOptions
	}{arg1, arg2})
	stub := fake.ListStub
	fakeReturns := fake.listReturns
	fake.recordInvocation("List", []interface{}{arg1, arg2})
	fake.listMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *PodInterface) ListCalls(stub func(context.Context, v1c.ListOptions) (*v1a.PodList, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *PodInterface) ListArgsForCall(i int) (context.Context, v1c.ListOptions) {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *PodInterface) ListReturns(result1 *v1a.PodList, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 *v1a.PodList
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) ListReturnsOnCall(i int, result1 *v1a.PodList, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 *v1a.PodList
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 *v1a.PodList
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) Patch(arg1 context.Context, arg2 string, arg3 types.PatchType, arg4 []byte, arg5 v1c.PatchOptions, arg6 ...string) (*v1a.Pod, error) {
	var arg4Copy []byte
	if arg4 != nil {
		arg4Copy = make([]byte, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 types.PatchType
		arg4 []byte
		arg5 v1c.PatchOptions
		arg6 []string
	}{arg1, arg2, arg3, arg4Copy, arg5, arg6})
	stub := fake.PatchStub
	fakeReturns := fake.patchReturns
	fake.recordInvocation("Patch", []interface{}{arg1, arg2, arg3, arg4Copy, arg5, arg6})
	fake.patchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *PodInterface) PatchCalls(stub func(context.Context, string, types.PatchType, []byte, v1c.PatchOptions, ...string) (*v1a.Pod, error)) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = stub
}

func (fake *PodInterface) PatchArgsForCall(i int) (context.Context, string, types.PatchType, []byte, v1c.PatchOptions, []string) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	argsForCall := fake.patchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *PodInterface) PatchReturns(result1 *v1a.Pod, result2 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) PatchReturnsOnCall(i int, result1 *v1a.Pod, result2 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 *v1a.Pod
			result2 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) ProxyGet(arg1 string, arg2 string, arg3 string, arg4 string, arg5 map[string]string) rest.ResponseWrapper {
	fake.proxyGetMutex.Lock()
	ret, specificReturn := fake.proxyGetReturnsOnCall[len(fake.proxyGetArgsForCall)]
	fake.proxyGetArgsForCall = append(fake.proxyGetArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 string
		arg5 map[string]string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ProxyGetStub
	fakeReturns := fake.proxyGetReturns
	fake.recordInvocation("ProxyGet", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.proxyGetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *PodInterface) ProxyGetCallCount() int {
	fake.proxyGetMutex.RLock()
	defer fake.proxyGetMutex.RUnlock()
	return len(fake.proxyGetArgsForCall)
}

func (fake *PodInterface) ProxyGetCalls(stub func(string, string, string, string, map[string]string) rest.ResponseWrapper) {
	fake.proxyGetMutex.Lock()
	defer fake.proxyGetMutex.Unlock()
	fake.ProxyGetStub = stub
}

func (fake *PodInterface) ProxyGetArgsForCall(i int) (string, string, string, string, map[string]string) {
	fake.proxyGetMutex.RLock()
	defer fake.proxyGetMutex.RUnlock()
	argsForCall := fake.proxyGetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *PodInterface) ProxyGetReturns(result1 rest.ResponseWrapper) {
	fake.proxyGetMutex.Lock()
	defer fake.proxyGetMutex.Unlock()
	fake.ProxyGetStub = nil
	fake.proxyGetReturns = struct {
		result1 rest.ResponseWrapper
	}{result1}
}

func (fake *PodInterface) ProxyGetReturnsOnCall(i int, result1 rest.ResponseWrapper) {
	fake.proxyGetMutex.Lock()
	defer fake.proxyGetMutex.Unlock()
	fake.ProxyGetStub = nil
	if fake.proxyGetReturnsOnCall == nil {
		fake.proxyGetReturnsOnCall = make(map[int]struct {
			result1 rest.ResponseWrapper
		})
	}
	fake.proxyGetReturnsOnCall[i] = struct {
		result1 rest.ResponseWrapper
	}{result1}
}

func (fake *PodInterface) Update(arg1 context.Context, arg2 *v1a.Pod, arg3 v1c.UpdateOptions) (*v1a.Pod, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 *v1a.Pod
		arg3 v1c.UpdateOptions
	}{arg1, arg2, arg3})
	stub := fake.UpdateStub
	fakeReturns := fake.updateReturns
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3})
	fake.updateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *PodInterface) UpdateCalls(stub func(context.Context, *v1a.Pod, v1c.UpdateOptions) (*v1a.Pod, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *PodInterface) UpdateArgsForCall(i int) (context.Context, *v1a.Pod, v1c.UpdateOptions) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) UpdateReturns(result1 *v1a.Pod, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) UpdateReturnsOnCall(i int, result1 *v1a.Pod, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *v1a.Pod
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) UpdateEphemeralContainers(arg1 context.Context, arg2 string, arg3 *v1a.Pod, arg4 v1c.UpdateOptions) (*v1a.Pod, error) {
	fake.updateEphemeralContainersMutex.Lock()
	ret, specificReturn := fake.updateEphemeralContainersReturnsOnCall[len(fake.updateEphemeralContainersArgsForCall)]
	fake.updateEphemeralContainersArgsForCall = append(fake.updateEphemeralContainersArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *v1a.Pod
		arg4 v1c.UpdateOptions
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateEphemeralContainersStub
	fakeReturns := fake.updateEphemeralContainersReturns
	fake.recordInvocation("UpdateEphemeralContainers", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateEphemeralContainersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) UpdateEphemeralContainersCallCount() int {
	fake.updateEphemeralContainersMutex.RLock()
	defer fake.updateEphemeralContainersMutex.RUnlock()
	return len(fake.updateEphemeralContainersArgsForCall)
}

func (fake *PodInterface) UpdateEphemeralContainersCalls(stub func(context.Context, string, *v1a.Pod, v1c.UpdateOptions) (*v1a.Pod, error)) {
	fake.updateEphemeralContainersMutex.Lock()
	defer fake.updateEphemeralContainersMutex.Unlock()
	fake.UpdateEphemeralContainersStub = stub
}

func (fake *PodInterface) UpdateEphemeralContainersArgsForCall(i int) (context.Context, string, *v1a.Pod, v1c.UpdateOptions) {
	fake.updateEphemeralContainersMutex.RLock()
	defer fake.updateEphemeralContainersMutex.RUnlock()
	argsForCall := fake.updateEphemeralContainersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *PodInterface) UpdateEphemeralContainersReturns(result1 *v1a.Pod, result2 error) {
	fake.updateEphemeralContainersMutex.Lock()
	defer fake.updateEphemeralContainersMutex.Unlock()
	fake.UpdateEphemeralContainersStub = nil
	fake.updateEphemeralContainersReturns = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) UpdateEphemeralContainersReturnsOnCall(i int, result1 *v1a.Pod, result2 error) {
	fake.updateEphemeralContainersMutex.Lock()
	defer fake.updateEphemeralContainersMutex.Unlock()
	fake.UpdateEphemeralContainersStub = nil
	if fake.updateEphemeralContainersReturnsOnCall == nil {
		fake.updateEphemeralContainersReturnsOnCall = make(map[int]struct {
			result1 *v1a.Pod
			result2 error
		})
	}
	fake.updateEphemeralContainersReturnsOnCall[i] = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) UpdateStatus(arg1 context.Context, arg2 *v1a.Pod, arg3 v1c.UpdateOptions) (*v1a.Pod, error) {
	fake.updateStatusMutex.Lock()
	ret, specificReturn := fake.updateStatusReturnsOnCall[len(fake.updateStatusArgsForCall)]
	fake.updateStatusArgsForCall = append(fake.updateStatusArgsForCall, struct {
		arg1 context.Context
		arg2 *v1a.Pod
		arg3 v1c.UpdateOptions
	}{arg1, arg2, arg3})
	stub := fake.UpdateStatusStub
	fakeReturns := fake.updateStatusReturns
	fake.recordInvocation("UpdateStatus", []interface{}{arg1, arg2, arg3})
	fake.updateStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) UpdateStatusCallCount() int {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return len(fake.updateStatusArgsForCall)
}

func (fake *PodInterface) UpdateStatusCalls(stub func(context.Context, *v1a.Pod, v1c.UpdateOptions) (*v1a.Pod, error)) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = stub
}

func (fake *PodInterface) UpdateStatusArgsForCall(i int) (context.Context, *v1a.Pod, v1c.UpdateOptions) {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	argsForCall := fake.updateStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *PodInterface) UpdateStatusReturns(result1 *v1a.Pod, result2 error) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = nil
	fake.updateStatusReturns = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) UpdateStatusReturnsOnCall(i int, result1 *v1a.Pod, result2 error) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = nil
	if fake.updateStatusReturnsOnCall == nil {
		fake.updateStatusReturnsOnCall = make(map[int]struct {
			result1 *v1a.Pod
			result2 error
		})
	}
	fake.updateStatusReturnsOnCall[i] = struct {
		result1 *v1a.Pod
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) Watch(arg1 context.Context, arg2 v1c.ListOptions) (watch.Interface, error) {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		arg1 context.Context
		arg2 v1c.ListOptions
	}{arg1, arg2})
	stub := fake.WatchStub
	fakeReturns := fake.watchReturns
	fake.recordInvocation("Watch", []interface{}{arg1, arg2})
	fake.watchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *PodInterface) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *PodInterface) WatchCalls(stub func(context.Context, v1c.ListOptions) (watch.Interface, error)) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = stub
}

func (fake *PodInterface) WatchArgsForCall(i int) (context.Context, v1c.ListOptions) {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	argsForCall := fake.watchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *PodInterface) WatchReturns(result1 watch.Interface, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) WatchReturnsOnCall(i int, result1 watch.Interface, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 watch.Interface
			result2 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *PodInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.applyStatusMutex.RLock()
	defer fake.applyStatusMutex.RUnlock()
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.evictMutex.RLock()
	defer fake.evictMutex.RUnlock()
	fake.evictV1Mutex.RLock()
	defer fake.evictV1Mutex.RUnlock()
	fake.evictV1beta1Mutex.RLock()
	defer fake.evictV1beta1Mutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.proxyGetMutex.RLock()
	defer fake.proxyGetMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateEphemeralContainersMutex.RLock()
	defer fake.updateEphemeralContainersMutex.RUnlock()
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *PodInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ v1.PodInterface = new(PodInterface)
